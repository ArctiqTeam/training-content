---
header:
  author: Justin Phelps
  title: Variable Types and Precedence
  description: Understanding variables and precedence.

slides:

  -
    - nested:
      - 
        - h1: "Variable Types and Precedence"
      - 
        - h2: "Where variables are defined or sourced:"
        - ul:
          - Inventory
          - Playbook
          - Files and Roles
          - Command Line
          - Facts
        - class_notes: 
      -
        - h2: "Variable Precedence"
        - p: "Variables will override each other depending on where they are defined:"
        - ol:
          - Command line variables have the highest precedence.
          - "'most everything else' come next."
          - Variables defined in inventory.
          - Next comes facts discovered about a system.
          - Role defaults lose in priority to everything else.
        - class_notes:
      -
        - h2: "Defining Variables"
        - p: Let's go over the various locations you can define variables.
        - class_notes:
      -
        - h2: "Inventory"
        - p: "There are a couple of methods for defining variables in your inventory:"
        - code: |
            localhost ansible_connection=local
            [web]
            web1.example.com ansible_ssh_port=5555 ansible_ssh_host=192.168.1.50
            web2.example.com ansible_ssh_user=mdehaan
            [db]
            db01.example.com mysql_max_connections=100
            [web:vars]
            apache_max_clients=100
        - class_notes: |
                There are a few examples here:
                  * The ansible ssh and connection options.
                  * A plain variable override for a specific host (mysql)
                  * A group variable override for the web group.
      -
        - h2: "Playbook"
        - p: "Here is an example of defining variables in a playbook:"
        - code: |
            - hosts: webservers
              vars:
                http_port: 80
        - class_notes:
      -
        - h2: "Command Line"
        - p: "You can also override variables from the command line:"
        - code: |
            ansible-playbook release.yml --extra-vars "version=1.23.45 other_variable=foo"
        - class_notes:
      -
        - h2: "Including Variable Files"
        - p: "Here is an example of including a variable file based on a condition:"
        - code: |
                - name: Includiung OS specific variables
                  include_vars: '{{ ansible_os_family }}.yml'
        - class_notes: |
                This example includes a file based on the ansible_os_family variable. This is typically Debian or RedHat for most systems.
      -
        - h2: "Roles"
        - p: "Ansible Roles also have variables that can be defined:"
        - ul:
          - "vars/main.yml contains variables that should stay internal to the role."
          - "defaults/main.yml contains variables that can be overridden."
        - class_notes:
      -
        - h2: "Facts"
        - p: "System facts are sourced from the following sources:"
        - ul:
          - setup module
          - set_fact
          - facts.d
        - class_notes: |
      -
        - h2: "Discovered Facts"
        - p: "Here is a sampling of facts discovered by the setup module:"
        - code: |
              ...
              "ansible_all_ipv4_addresses": [
                  "REDACTED IP ADDRESS"
              ],
              "ansible_all_ipv6_addresses": [
                  "REDACTED IPV6 ADDRESS"
              ],
              "ansible_architecture": "x86_64",
              "ansible_bios_date": "09/20/2012",
              "ansible_bios_version": "6.00",
              "ansible_cmdline": {
                  "BOOT_IMAGE": "/boot/vmlinuz-3.5.0-23-generic",
                  "quiet": true,
                  "ro": true,
                  "root": "UUID=4195bff4-e157-4e41-8701-e93f0aec9e22",
                  "splash": true
              },
              "ansible_date_time": {
                  "date": "2013-10-02",
                  "day": "02",
                  "epoch": "1380756810",
                  "hour": "19",
                  "iso8601": "2013-10-02T23:33:30Z",
                  "iso8601_micro": "2013-10-02T23:33:30.036070Z",
                  "minute": "33",
                  "month": "10",
                  "second": "30",
                  "time": "19:33:30",
                  "tz": "EDT",
                  "year": "2013"
              },
              "ansible_default_ipv4": {
                  "address": "REDACTED",
                  "alias": "eth0",
                  "gateway": "REDACTED",
                  "interface": "eth0",
                  "macaddress": "REDACTED",
                  "mtu": 1500,
                  "netmask": "255.255.255.0",
                  "network": "REDACTED",
                  "type": "ether"
              },
              ...
        - class_notes: |
      - 
        - h2: "Discovered Facts"
        - p: "Here is how you reference these variables:"
        - code: |
            {{ ansible_devices.sda.model }}
            {{ ansible_hostname }}
      -
        - h2: "Setting Facts in a Play"
        - p: "You can set facts manually in a play:"
        - code: |
            # Example setting host facts using key=value pairs
            - set_fact: one_fact="something" other_fact="{{ local_var * 2 }}"
            
            # Example setting host facts using complex arguments
            - set_fact:
                 one_fact: something
                 other_fact: "{{ local_var * 2 }}"
        - class_notes:
      -
        - h2: "Local Facts (Facts.d)"
        - p: "You can place files ending in '.fact' in the /etc/ansible/facts.d directory. These can be JSON, INI, or executable files. Here is an example file:"
        - code: |
            [general]
            asdf=1
            bar=2
            
            {{ ansible_local.preferences.general.asdf }}
        - class_notes: |
            The code sample shows the file to be dropped, and the way to reference that variable in templates and plays.
      -
        - h2: "Using Variables in Jinja2"
        - p: "You've seen several examples of variables being referenced. The same method is used to reference these variables in Jinja2 templates."
        - code: |
                {{ variable_name }}
        - class_notes: |
      -
        - h2: "Jinja2 Filters" 
        - p: "There are many useful filters you can use in your Jinja2 templates. Here are a few useful ones:"
        - code: |
                # Combine two lists
                {{ list1 | union(list2) }}
                # Get a random number
                {{ 59 |random}} * * * * root /script/from/cron
                # md5sum of a filename
                {{ filename | md5 }}
                # Comparisons
                {{ ansible_distribution_version | verson_compare('12.04', '>=') }}
        - class_notes: |
                There are a lot more filters out there. Reference the Ansible and Jinja2 documentation for a complete list.
      - 
        - h2: "Defaulting Values"
        - p: "You can provide a default value for a variable using the following filter:"
        - code: |
                {{ some_variable | default("foobar") }}
        - class_notes: |
      -
        - h2: Module Interactions in Tasks
        - p: A series of tasks
        - code: |
            - name: add cache dir
              file: path=/opt/cache state=directory

            - name: install nginx
              yum: name=nginx state=present

            - name: start nginx
              service: name=nginx enabled=yes state=started
        - class_notes: |
            An ordered series of tasks can be described to form plays.  Tasks utilize modules to act upon remote hosts.
      -
        - h2: Plays
        - p: Plays are ordered sets of tasks to execute against host selections from your inventory.
        - p: "This topic will cover:"
        - ul:
          - play naming
          - hosts selection
          - play arguments
          - variables
          - tasks
          - concurrency and order of operations
          - conditionals
          - error handling
          - inclusions
      -
        - h2: Play Naming
        - code: |
            - name: This is a Play
        - class_notes: General best practices are to name tasks in a way that shows what they do.
      - 
        - h2: Hosts Selection
        - code: |
            - name: This is a Play
              hosts: web-servers
        - class_notes: This is how we specify in a play/plabook what hosts we will act upon based on group.
      -
        - h2: Play Arguments
        - code: |
            - name: This is a Play
              hosts: web-servers
              remote_user: fred
              sudo: yes
              connection: ssh
        - class_notes: |
            Furthermore, we can specify other variables as arguments.  
            Such as what remote user to connect as, or whether we sudo to root to complete our task.
      -
        - h2: Variables
        - code: |
            - name: This is a Play
              hosts: web-servers
              remote_user: fred
              sudo: yes
              connection: ssh
              vars:
                http_port: 80
                cache_dir: /opt/cache
        - class_notes: |
            We gather facts before every run from hosts we are acting on.  Facts become variables that
            contain information such as kernel level, host name, ip addresses and other standard information.
      -
        - h2: Tasks
        - code: |
            - name: This is a Play
              hosts: web-servers
              remote_user: fred
              sudo: yes
              connection: ssh
              gather_facts: no
              vars:
                http_port: 80
                cache_dir: /opt/cache

              tasks:
                - name: create cache dir
                  file: path={{ cache_dir }} state=directory

                - name: install nginx
                  yum: name=nginx state=installed
        - class_notes: |
            This is a compelte example of a play within a playbook.  It contains arguments, variables,
            host groups to act on, two tasks and wheteher we use sudo on those tasks.  It also uses the variables
            specified for the cache directory.  Variables are represented in the Jinja2 format with double curly braces.
      -
        - h2: Concurrency and Order of Operations
        - code: |
            - name: This is a Play
              hosts: web-servers
              remote_user: fred
              sudo: yes
              connection: ssh
              vars:
                http_port: 80
                cache_dir: /opt/cache

              tasks:
                - name: create cache dir
                  file: path={{ cache_dir }} state=directory

                - name: install nginx
                  yum: name=nginx state=installed
        - class_notes: |
            You can specify number of concurrent machines to act upon via setting a number of forks.  That will act upon 
            that number of hosts at once, however the tasks within the play complete from top to botton, in order, one at a time.
      -
        - h2: Conditionals
        - code: |
            - name: This is a Play
              hosts: web-servers
              remote_user: fred
              sudo: yes
              connection: ssh
              vars:
                http_port: 80
                cache_dir: /opt/cache

              tasks:
                - name: create cache dir
                  file: path={{ cache_dir }} state=directory

                - name: install nginx
                  yum: name=httpd state=installed
                  when: ansible_os_family == "RedHat"

                - name: install nginx
                  apt: pkg=apache2 state=installed
                  when: ansible_os_family == "Debian"
        - class_notes: |
            This is an example of a conditional. Conditionals allow for actions to be dependant on some fact or variable set.
            In this case, we see that we install nginx via Linux-Distro specific package managers. The variable "ansible_os_family"
            is a discovered fact gathered when we first run the play or playbook against hosts.
      -
        - h2: Error Handling
        - code: |
            - name: This is a Play
              hosts: web-servers
              remote_user: fred
              sudo: yes
              connection: ssh
              vars:
                http_port: 80
                cache_dir: /opt/cache

              tasks:
                - name: create cache dir
                  file: path={{ cache_dir }} state=directory

                - name: install nginx
                  yum: name=httpd state=installed
                  when: ansible_os_family == "RedHat"

                - name: install nginx
                  apt: pkg=apache2 state=installed
                  when: ansible_os_family == "Debian"

                - name: failing command
                  command: /bin/fail
                  ignore_errors: yes
        - class_notes: |
            In this example we see the use of the "ignore_errors" setting, allowing users to dictate to ansible
            to ignore when the return codes of ansible-initiated tasks indicate failures or errors.  Another way
            to do this is by using the "failed_when" options.
      -
        - h2: Inclusions
        - code: |
            - name: This is a Play
              hosts: web-servers
              remote_user: fred
              sudo: yes
              connection: ssh
              vars_files:
                - vars/nginx.yaml

              tasks:
                - name: create cache dir
                  file: path={{ cache_dir }} state=directory

                - include: tasks/install-apache.yaml

                - name: failing command
                  command: /bin/fail
                  ignore_errors: yes
        - class_notes: |
            Take note of the "include" task: This allows us to include other playbooks at specific points in our
            run allowing for complicated aspects of orchestration to be seamless based on function or type of 
            playbook.  While this is useful, most often now you will use Roles for this functionality.  We'll talk
            more about those in a bit.
      -
        - h2: Playbooks
        - p: Playbooks are ordered sets of plays to execute against inventory selections.
        - p: "This topic will cover:"
        - ul:
          - inventory selection
          - global variables
          - forks
          - inventory limits
          - inclusions
          - roles
      -
        - h2: Inventory Selection
        - code: |
            $ ansible-playbook -i production play.yaml
            $ ansible-playbook -i pre-prod play.yaml
            $ ansible-playbook -i hosts/dfw/ play.yaml
        - class_notes: |
            As you can see, we can specify different inventories to run the playbook "play.yaml" against.
      -
        - h2: Global Variables
        - code: |
            $ ansible-playbook -i pre-prod -e "cache_dir=/srv/cache/" play.yaml
        - class_notes: Variables declared in this manner from the command line override other values.
      -
        - h2: Forks
        - code: |
            $ ansible-playbook -f 30 -i pre-prod -e "cache_dir=/srv/cache/" play.yaml
        - class_notes: |
            This shows us declaring this playbook to be run against 30 hosts at a time by delcaring 
            "-f 30" which is the flag for "forks equals 30 at a time."
      -
        - h2: Inventory-Limits
        - code: |
            $ ansible-playbook --limit dfw -f 30 -i pre-prod -e "cache_dir=/srv/cache/" play.yaml
        - class_notes: |
            This shows us running a playbook while declaring a limit to run only against "DFW" 
            which could mean a single host named DFW, or a host group DFW.
      -
        - h2: Inclusions
        - code: |
            - name: This is a Play
              hosts: web-servers
              remote_user: fred
              sudo: yes
              connection: ssh
              gather_facts: no
              vars:
                http_port: 80
                cache_dir: /opt/cache

              tasks:
                - name: create cache dir
                  file: path={{ cache_dir }} state=directory

            - include: playbook2.yaml
        - class_notes: |
            In this example we see that at the end of the playbook, we include another playbook.  This allows
            us to continue against other playbooks using the already discovered facts and variables declared.
      -
        - h2: Roles
        - p: Roles are portable units of task organization in playbooks.
        - class_notes: |
            Roles are units of organization in Ansible. Assigning a role to a group of hosts 
            (or a set of groups, or host patterns, etc.) implies that they should implement a 
            specific behavior. A role may include applying certain variable values, certain tasks, 
            and certain handlers - or just one or more of these things. Because of the file structure 
            associated with a role, roles become redistributable units that allow you to share 
            behavior among playbooks - or even with other users.
      -
        - h2: "Galaxy: Sharing is Caring"
        - p: The Galaxy is a site where you can share roles.
        - link: ['http://galaxy.ansible.com',
                 'http://galaxy.ansible.com']
        - class_notes: |
            Galaxy is our repository for general roles that can be shared among users.  You can find it at the 
            address provided above.  You can share your roles, rate other people's roles, and download them
            via the command line using the ansible galaxy commads.  You can also create an empty role to build
            by initializing an empty role, which will populate all the correct files and directories for you.
